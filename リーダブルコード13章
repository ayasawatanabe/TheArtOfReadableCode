リーダブルコード
第十三章
短いコードを書く

■13.1
コードを書く必要がない場合は書かないこと！
コードを書くとテスト、保守の手間が増える
ライブラリの再利用や機能の削除をすることで、時間を節約したり、コードを簡潔に維持することができる

機能を過剰に盛り込まない
要求を正しく知り、問題を簡単にする

■13.2質問と要求の分割
例：店舗検索システム
// 任意のユーザの経緯緯度に対して、最も近い店舗を検索する
100%正しく実装するためには以下を考慮する必要がある
・日付変更線をまたいでいる時の処理
・北極や南極に近い時の処理
・「1マイルあたりの経度」に対応した地球の曲率の調整
考えればいいのはテキサス州にある20件の店舗だけ上記の条件を考える必要はない
必要なのは
・現在地と全ての店舗との距離を計算する

例：キャッシュを追加する
LRU方式(参照されていない時間が最も長い項目を削除する方式)
しかしアクセスが必ず順番にされる場合単項目キャッシュ(one-item-cache)で実現可能
この方がコード量が少なくて済む
DiskObject lastUsed; // クラスのメンバ
DiskObject lookUp(String key) {
  if(lastUsed == null || lastUsed.key().equals(key)) {
    lastUsed = localDiskObject(key);
  }
  return lastUsed;
}

■13.3コードを小さく保つ
システムは成長するそれらを結びつける複雑さはもっと早い速度で成長する。
・汎用的な「ユーティリティ」コードを作って重複コードを削除する(無関係の下位問題を抽出する)
・未使用のコードや無用の機能を整理する
・プロジェクトをサブプロジェクトに分割する
・コードの重量を意識する。軽量で俊敏にしておく

■13.4身近なライブラリに親しむ
・標準ライブラリの全ての関数・モジュール・型の名前を15分かけて読んでみる。
C++：標準テンプレートライブラリ(STL)
Java：API
Python：組み込みモジュール

例：pythonのリストとセット
// [2,1,2]リストから重複を取り除く -> [2,1]
// ディクショナリを使って実装すればキーを一意にしてくれる
def unique(elements):
  temp = {}
  for element in elements:
    temp[element] = None # 値はなんでもいい
  return temp.keys()
unique_elements = unique([2,1,2])

// set型でも可能
unique_elements = set([2,1,2]) # 重複の削除

// イテレートもできる。リストオブジェクトが必要なら
unique_elements = list(set([2,1,2])) # 重複の削除

■13.5コーディングするよりもUnixツールボックスを使う
例：アクセスログの解析
// 4xxや5xxのレスポンスコードを返してくるurl-pathを見つけるプログラム
　C++やjavaで書くと20行以上になる

// Unixコマンドでは
cat access.log | awk ‘{ print $5 “ ” $7}’ | egrep”[45]…$”¥
| sort | uniq -c | sort -nr

■13.6まとめ
できるだけコードを書かないこと
新しいコードには、テストや文章の保守が必要になる
コードが増えると重くなり開発が難しくなる

・不必要な機能をプロダクトから削除する。過剰な機能は持たせない
・最も簡単に問題解決できるような要求を考える
・定期的に全てのAPIを読んで標準ライブラリに慣れ親しんでおく。

